<!DOCTYPE html>
<html>
<head>
  <title>Facemoji</title>
  <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/main.css') }}">
</head>
<body>
  <h1>Hi, welcome to Facemoji!</h1>
  <video id="video" width="640" height="480" autoplay></video>
  <canvas id="canvas" style="display:none;"></canvas>
  <br>
  <button id="capture">Capture & Upload</button>
  <button id="predict">Predict Emotion</button>  <!-- New button for prediction -->

  <p id="status">Status: Waiting for capture...</p>
  <p id="timestamp"></p>
  <p id="docId"></p>

  <script>
    document.addEventListener("DOMContentLoaded", function() {
      const video = document.getElementById("video");
      const canvas = document.getElementById("canvas");
      const statusText = document.getElementById("status");
      const timestampText = document.getElementById("timestamp");
      const docIdText = document.getElementById("docId");

      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          video.srcObject = stream;
          statusText.textContent = "Status: Camera is working!";
        })
        .catch(err => {
          statusText.textContent = "Status: Camera error - " + err.message;
        });

      // Capture & Upload button logic
      document.getElementById("capture").onclick = async () => {
        const ctx = canvas.getContext("2d");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        const base64Image = canvas.toDataURL("image/jpeg");

        try {
          // Send the image directly to the /upload route for storage
          const res = await fetch("/upload", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ image: base64Image })
          });

          const result = await res.json();

          if (result.status) {
            statusText.textContent = result.status;
            timestampText.textContent = "Uploaded at: " + result.timestamp;
            docIdText.textContent = "Document ID: " + result.id;
          } else {
            statusText.textContent = "Error: " + result.error;
            timestampText.textContent = "";
            docIdText.textContent = "";
          }
        } catch (err) {
          statusText.textContent = "Upload failed: " + err.message;
          statusText.style.color = "red";
        }
      };

      // Predict Emotion button logic
      document.getElementById("predict").onclick = async () => {
        const ctx = canvas.getContext("2d");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        const base64Image = canvas.toDataURL("image/jpeg");

        try {
          // Send the image directly to the /predict_from_webapp route for emotion prediction
          const res = await fetch("http://localhost:8000/predict_from_webapp", {  // Update the URL if needed
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ image: base64Image })
          });

          const result = await res.json();

            if (result.error) {
            statusText.textContent = "Error: " + result.error;
            timestampText.textContent = "";
            docIdText.textContent = "";
            } else {
            // find highest percentage of emotion
            const topEmotion = Object.entries(result).reduce((max, entry) =>
                entry[1] > max[1] ? entry : max
            )[0];

            const emojiMap = {
                angry: "ğŸ˜ ",
                disgust: "ğŸ¤¢",
                fear: "ğŸ˜±",
                happy: "ğŸ˜„",
                neutral: "ğŸ˜",
                sad: "ğŸ˜¢",
                surprise: "ğŸ˜²"
            };
            const emoji = emojiMap[topEmotion] || "â“";
            statusText.textContent = `Emotion: ${topEmotion} ${emoji}`;
            timestampText.textContent = "";
            docIdText.textContent = "Results have been saved.";
            }
        } catch (err) {
          statusText.textContent = "Prediction failed: " + err.message;
          statusText.style.color = "red";
        }
      };
    });
  </script>
</body>
</html>
